"use strict";
var _object_spread = require("@swc/helpers/_/_object_spread");
var _object_spread_props = require("@swc/helpers/_/_object_spread_props");
var _sliced_to_array = require("@swc/helpers/_/_sliced_to_array");
var _type_of = require("@swc/helpers/_/_type_of");
(function(global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@floating-ui/dom'), require('react'), require('react-dom')) : typeof define === 'function' && define.amd ? define([
        'exports',
        '@floating-ui/dom',
        'react',
        'react-dom'
    ], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.FloatingUIReactDOM = {}, global.FloatingUIDOM, global.React, global.ReactDOM));
})(void 0, function(exports1, dom, React, ReactDOM) {
    'use strict';
    function _interopNamespaceDefault(e) {
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function(k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function get() {
                            return e[k];
                        }
                    });
                }
            });
        }
        n.default = e;
        return Object.freeze(n);
    }
    var React__namespace = /*#__PURE__*/ _interopNamespaceDefault(React);
    var ReactDOM__namespace = /*#__PURE__*/ _interopNamespaceDefault(ReactDOM);
    var index = typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect;
    // Fork of `fast-deep-equal` that only does the comparisons we need and compares
    // functions
    function deepEqual(a, b) {
        if (a === b) {
            return true;
        }
        if ((typeof a === "undefined" ? "undefined" : _type_of._(a)) !== (typeof b === "undefined" ? "undefined" : _type_of._(b))) {
            return false;
        }
        if (typeof a === 'function' && a.toString() === b.toString()) {
            return true;
        }
        var length;
        var i;
        var keys;
        if (a && b && typeof a === 'object') {
            if (Array.isArray(a)) {
                length = a.length;
                if (length !== b.length) return false;
                for(i = length; i-- !== 0;){
                    if (!deepEqual(a[i], b[i])) {
                        return false;
                    }
                }
                return true;
            }
            keys = Object.keys(a);
            length = keys.length;
            if (length !== Object.keys(b).length) {
                return false;
            }
            for(i = length; i-- !== 0;){
                if (!({}).hasOwnProperty.call(b, keys[i])) {
                    return false;
                }
            }
            for(i = length; i-- !== 0;){
                var key = keys[i];
                if (key === '_owner' && a.$$typeof) {
                    continue;
                }
                if (!deepEqual(a[key], b[key])) {
                    return false;
                }
            }
            return true;
        }
        return a !== a && b !== b;
    }
    function getDPR(element) {
        if (typeof window === 'undefined') {
            return 1;
        }
        var win = element.ownerDocument.defaultView || window;
        return win.devicePixelRatio || 1;
    }
    function roundByDPR(element, value) {
        var dpr = getDPR(element);
        return Math.round(value * dpr) / dpr;
    }
    function useLatestRef(value) {
        var ref = React__namespace.useRef(value);
        index(function() {
            ref.current = value;
        });
        return ref;
    }
    /**
   * Provides data to position a floating element.
   * @see https://floating-ui.com/docs/useFloating
   */ function useFloating(options) {
        if (options === void 0) {
            options = {};
        }
        var _options_placement = options.placement, placement = _options_placement === void 0 ? 'bottom' : _options_placement, _options_strategy = options.strategy, strategy = _options_strategy === void 0 ? 'absolute' : _options_strategy, _options_middleware = options.middleware, middleware = _options_middleware === void 0 ? [] : _options_middleware, platform = options.platform, tmp = options.elements, _ref = tmp === void 0 ? {} : tmp, externalReference = _ref.reference, externalFloating = _ref.floating, _options_transform = options.transform, transform = _options_transform === void 0 ? true : _options_transform, whileElementsMounted = options.whileElementsMounted, open = options.open;
        var _React__namespace_useState = _sliced_to_array._(React__namespace.useState({
            x: 0,
            y: 0,
            strategy: strategy,
            placement: placement,
            middlewareData: {},
            isPositioned: false
        }), 2), data = _React__namespace_useState[0], setData = _React__namespace_useState[1];
        var _React__namespace_useState1 = _sliced_to_array._(React__namespace.useState(middleware), 2), latestMiddleware = _React__namespace_useState1[0], setLatestMiddleware = _React__namespace_useState1[1];
        if (!deepEqual(latestMiddleware, middleware)) {
            setLatestMiddleware(middleware);
        }
        var _React__namespace_useState2 = _sliced_to_array._(React__namespace.useState(null), 2), _reference = _React__namespace_useState2[0], _setReference = _React__namespace_useState2[1];
        var _React__namespace_useState3 = _sliced_to_array._(React__namespace.useState(null), 2), _floating = _React__namespace_useState3[0], _setFloating = _React__namespace_useState3[1];
        var setReference = React__namespace.useCallback(function(node) {
            if (node !== referenceRef.current) {
                referenceRef.current = node;
                _setReference(node);
            }
        }, []);
        var setFloating = React__namespace.useCallback(function(node) {
            if (node !== floatingRef.current) {
                floatingRef.current = node;
                _setFloating(node);
            }
        }, []);
        var referenceEl = externalReference || _reference;
        var floatingEl = externalFloating || _floating;
        var referenceRef = React__namespace.useRef(null);
        var floatingRef = React__namespace.useRef(null);
        var dataRef = React__namespace.useRef(data);
        var hasWhileElementsMounted = whileElementsMounted != null;
        var whileElementsMountedRef = useLatestRef(whileElementsMounted);
        var platformRef = useLatestRef(platform);
        var update = React__namespace.useCallback(function() {
            if (!referenceRef.current || !floatingRef.current) {
                return;
            }
            var config = {
                placement: placement,
                strategy: strategy,
                middleware: latestMiddleware
            };
            if (platformRef.current) {
                config.platform = platformRef.current;
            }
            dom.computePosition(referenceRef.current, floatingRef.current, config).then(function(data) {
                var fullData = _object_spread_props._(_object_spread._({}, data), {
                    isPositioned: true
                });
                if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
                    dataRef.current = fullData;
                    ReactDOM__namespace.flushSync(function() {
                        setData(fullData);
                    });
                }
            });
        }, [
            latestMiddleware,
            placement,
            strategy,
            platformRef
        ]);
        index(function() {
            if (open === false && dataRef.current.isPositioned) {
                dataRef.current.isPositioned = false;
                setData(function(data) {
                    return _object_spread_props._(_object_spread._({}, data), {
                        isPositioned: false
                    });
                });
            }
        }, [
            open
        ]);
        var isMountedRef = React__namespace.useRef(false);
        index(function() {
            isMountedRef.current = true;
            return function() {
                isMountedRef.current = false;
            };
        }, []);
        index(function() {
            if (referenceEl) referenceRef.current = referenceEl;
            if (floatingEl) floatingRef.current = floatingEl;
            if (referenceEl && floatingEl) {
                if (whileElementsMountedRef.current) {
                    return whileElementsMountedRef.current(referenceEl, floatingEl, update);
                }
                update();
            }
        }, [
            referenceEl,
            floatingEl,
            update,
            whileElementsMountedRef,
            hasWhileElementsMounted
        ]);
        var refs = React__namespace.useMemo(function() {
            return {
                reference: referenceRef,
                floating: floatingRef,
                setReference: setReference,
                setFloating: setFloating
            };
        }, [
            setReference,
            setFloating
        ]);
        var elements = React__namespace.useMemo(function() {
            return {
                reference: referenceEl,
                floating: floatingEl
            };
        }, [
            referenceEl,
            floatingEl
        ]);
        var floatingStyles = React__namespace.useMemo(function() {
            var initialStyles = {
                position: strategy,
                left: 0,
                top: 0
            };
            if (!elements.floating) {
                return initialStyles;
            }
            var x = roundByDPR(elements.floating, data.x);
            var y = roundByDPR(elements.floating, data.y);
            if (transform) {
                return _object_spread._(_object_spread_props._(_object_spread._({}, initialStyles), {
                    transform: "translate(" + x + "px, " + y + "px)"
                }), getDPR(elements.floating) >= 1.5 && {
                    willChange: 'transform'
                });
            }
            return {
                position: strategy,
                left: x,
                top: y
            };
        }, [
            strategy,
            transform,
            elements.floating,
            data.x,
            data.y
        ]);
        return React__namespace.useMemo(function() {
            return _object_spread_props._(_object_spread._({}, data), {
                update: update,
                refs: refs,
                elements: elements,
                floatingStyles: floatingStyles
            });
        }, [
            data,
            update,
            refs,
            elements,
            floatingStyles
        ]);
    }
    /**
   * Provides data to position an inner element of the floating element so that it
   * appears centered to the reference element.
   * This wraps the core `arrow` middleware to allow React refs as the element.
   * @see https://floating-ui.com/docs/arrow
   */ var arrow$1 = function(options) {
        var isRef = function isRef(value) {
            return ({}).hasOwnProperty.call(value, 'current');
        };
        return {
            name: 'arrow',
            options: options,
            fn: function fn(state) {
                var _ref = typeof options === 'function' ? options(state) : options, element = _ref.element, padding = _ref.padding;
                if (element && isRef(element)) {
                    if (element.current != null) {
                        return dom.arrow({
                            element: element.current,
                            padding: padding
                        }).fn(state);
                    }
                    return {};
                }
                if (element) {
                    return dom.arrow({
                        element: element,
                        padding: padding
                    }).fn(state);
                }
                return {};
            }
        };
    };
    /**
   * Modifies the placement by translating the floating element along the
   * specified axes.
   * A number (shorthand for `mainAxis` or distance), or an axes configuration
   * object may be passed.
   * @see https://floating-ui.com/docs/offset
   */ var offset = function(options, deps) {
        return _object_spread_props._(_object_spread._({}, dom.offset(options)), {
            options: [
                options,
                deps
            ]
        });
    };
    /**
   * Optimizes the visibility of the floating element by shifting it in order to
   * keep it in view when it will overflow the clipping boundary.
   * @see https://floating-ui.com/docs/shift
   */ var shift = function(options, deps) {
        return _object_spread_props._(_object_spread._({}, dom.shift(options)), {
            options: [
                options,
                deps
            ]
        });
    };
    /**
   * Built-in `limiter` that will stop `shift()` at a certain point.
   */ var limitShift = function(options, deps) {
        return _object_spread_props._(_object_spread._({}, dom.limitShift(options)), {
            options: [
                options,
                deps
            ]
        });
    };
    /**
   * Optimizes the visibility of the floating element by flipping the `placement`
   * in order to keep it in view when the preferred placement(s) will overflow the
   * clipping boundary. Alternative to `autoPlacement`.
   * @see https://floating-ui.com/docs/flip
   */ var flip = function(options, deps) {
        return _object_spread_props._(_object_spread._({}, dom.flip(options)), {
            options: [
                options,
                deps
            ]
        });
    };
    /**
   * Provides data that allows you to change the size of the floating element —
   * for instance, prevent it from overflowing the clipping boundary or match the
   * width of the reference element.
   * @see https://floating-ui.com/docs/size
   */ var size = function(options, deps) {
        return _object_spread_props._(_object_spread._({}, dom.size(options)), {
            options: [
                options,
                deps
            ]
        });
    };
    /**
   * Optimizes the visibility of the floating element by choosing the placement
   * that has the most space available automatically, without needing to specify a
   * preferred placement. Alternative to `flip`.
   * @see https://floating-ui.com/docs/autoPlacement
   */ var autoPlacement = function(options, deps) {
        return _object_spread_props._(_object_spread._({}, dom.autoPlacement(options)), {
            options: [
                options,
                deps
            ]
        });
    };
    /**
   * Provides data to hide the floating element in applicable situations, such as
   * when it is not in the same clipping context as the reference element.
   * @see https://floating-ui.com/docs/hide
   */ var hide = function(options, deps) {
        return _object_spread_props._(_object_spread._({}, dom.hide(options)), {
            options: [
                options,
                deps
            ]
        });
    };
    /**
   * Provides improved positioning for inline reference elements that can span
   * over multiple lines, such as hyperlinks or range selections.
   * @see https://floating-ui.com/docs/inline
   */ var inline = function(options, deps) {
        return _object_spread_props._(_object_spread._({}, dom.inline(options)), {
            options: [
                options,
                deps
            ]
        });
    };
    /**
   * Provides data to position an inner element of the floating element so that it
   * appears centered to the reference element.
   * This wraps the core `arrow` middleware to allow React refs as the element.
   * @see https://floating-ui.com/docs/arrow
   */ var arrow = function(options, deps) {
        return _object_spread_props._(_object_spread._({}, arrow$1(options)), {
            options: [
                options,
                deps
            ]
        });
    };
    Object.defineProperty(exports1, "autoUpdate", {
        enumerable: true,
        get: function get() {
            return dom.autoUpdate;
        }
    });
    Object.defineProperty(exports1, "computePosition", {
        enumerable: true,
        get: function get() {
            return dom.computePosition;
        }
    });
    Object.defineProperty(exports1, "detectOverflow", {
        enumerable: true,
        get: function get() {
            return dom.detectOverflow;
        }
    });
    Object.defineProperty(exports1, "getOverflowAncestors", {
        enumerable: true,
        get: function get() {
            return dom.getOverflowAncestors;
        }
    });
    Object.defineProperty(exports1, "platform", {
        enumerable: true,
        get: function get() {
            return dom.platform;
        }
    });
    exports1.arrow = arrow;
    exports1.autoPlacement = autoPlacement;
    exports1.flip = flip;
    exports1.hide = hide;
    exports1.inline = inline;
    exports1.limitShift = limitShift;
    exports1.offset = offset;
    exports1.shift = shift;
    exports1.size = size;
    exports1.useFloating = useFloating;
});
