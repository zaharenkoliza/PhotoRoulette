{"version":3,"sources":["../../../../src/hooks/useDraggableWithDomApi/useDraggableWithDomApi.ts"],"sourcesContent":["import * as React from 'react';\nimport type { CustomTouchEvent } from '../../components/Touch/Touch';\nimport { getBoundingClientRect, getNearestOverflowAncestor, getNodeScroll } from '../../lib/dom';\nimport { useIsomorphicLayoutEffect } from '../../lib/useIsomorphicLayoutEffect';\nimport { createAutoScrollController, getAutoScrollingData } from './autoScroll';\nimport {\n  AUTO_SCROLL_START_DELAY,\n  DATA_DRAGGABLE_PLACEHOLDER_KEY,\n  ITEM_INITIAL_INDEX,\n} from './constants';\nimport type {\n  Direction,\n  DraggingItem,\n  PlaceholderItem,\n  SiblingItem,\n  UseDraggable,\n  UseDraggableProps,\n} from './types';\nimport {\n  getTargetIsOverOrUnderElData,\n  setDraggingItemShiftStyles,\n  setInitialDraggingItemStyles,\n  setInitialPlaceholderItemStyles,\n  setInitialSiblingItemStyles,\n  setSiblingItemsShiftStyles,\n  unsetInitialDraggingItemStyles,\n  unsetInitialPlaceholderItemStyles,\n  unsetInitialSiblingItemStyles,\n} from './utils';\n\nexport const useDraggableWithDomApi = <T extends HTMLElement>({\n  elRef: draggingElRef,\n  onDragFinish,\n}: UseDraggableProps<T>): UseDraggable => {\n  const [dragging, setDragging] = React.useState(false);\n  const lastClientYRef = React.useRef(0);\n  const lastDragShiftYRef = React.useRef(0);\n\n  const scrollElRef = React.useRef<Element | Window | null>(null);\n  const lastScrollTopRef = React.useRef<number>(0);\n  const scrollControllerRef = React.useRef<ReturnType<typeof createAutoScrollController> | null>(\n    null,\n  );\n  const initializeScrollRefs = (draggableEl: HTMLElement) => {\n    const node = getNearestOverflowAncestor(draggableEl);\n    if (node) {\n      scrollElRef.current = node;\n      lastScrollTopRef.current = getNodeScroll(node).scrollTop;\n      scrollControllerRef.current = createAutoScrollController(scrollElRef.current);\n    }\n  };\n  const cleanupScrollRefs = () => {\n    lastScrollTopRef.current = 0;\n    scrollControllerRef.current?.stop();\n    scrollElRef.current = scrollControllerRef.current = null;\n  };\n\n  const lastDragDirectionRef = React.useRef<Direction | undefined>(undefined);\n  const toggleDragDirection = (prevShiftY: number, nextShiftY: number) => {\n    const shiftYDiff = prevShiftY - nextShiftY;\n    if (shiftYDiff < 0) {\n      return 'down';\n    }\n    if (shiftYDiff > 0) {\n      return 'up';\n    }\n    return lastDragDirectionRef.current;\n  };\n\n  const itemStartIndexRef = React.useRef<number>(ITEM_INITIAL_INDEX);\n  const itemEndIndexRef = React.useRef<number>(ITEM_INITIAL_INDEX);\n  const draggingItemRef = React.useRef<DraggingItem | null>(null);\n  const placeholderItemRef = React.useRef<PlaceholderItem | null>(null);\n  const siblingItemsRef = React.useRef<SiblingItem[]>([]);\n  const itemsGapRef = React.useRef<number>(0);\n  const initializeItems = (draggingEl: HTMLElement) => {\n    const draggingElRect = getBoundingClientRect(draggingEl, true);\n    const parentElement = draggingEl.parentElement;\n    itemsGapRef.current = parentElement ? parseInt(parentElement.style.gridGap) : 0;\n\n    const { children } = parentElement || { children: [] };\n    Array.prototype.forEach.call(children, (el: HTMLElement, index) => {\n      if (el === draggingEl) {\n        itemStartIndexRef.current = itemEndIndexRef.current = index;\n        draggingItemRef.current = { index, el, draggingElRect };\n      } else if (el.getAttribute(DATA_DRAGGABLE_PLACEHOLDER_KEY) !== null) {\n        placeholderItemRef.current = { index, el, draggingElRect };\n      } else {\n        siblingItemsRef.current.push({ index, el, shifted: itemStartIndexRef.current !== ITEM_INITIAL_INDEX && itemStartIndexRef.current < index, draggingElRect }); // prettier-ignore\n      }\n    });\n    if (placeholderItemRef.current) {\n      setInitialPlaceholderItemStyles(placeholderItemRef.current); // 1. reflow\n    }\n    if (draggingItemRef.current) {\n      setInitialDraggingItemStyles(draggingItemRef.current); // 2. repaint\n    }\n    siblingItemsRef.current.forEach((sibling) =>\n      setInitialSiblingItemStyles(sibling, itemsGapRef.current),\n    ); // 2. repaint\n  };\n  const cleanupItems = () => {\n    if (placeholderItemRef.current) {\n      unsetInitialPlaceholderItemStyles(placeholderItemRef.current); // 1. reflow\n    }\n    if (draggingItemRef.current) {\n      unsetInitialDraggingItemStyles(draggingItemRef.current); // 2. repaint\n    }\n    siblingItemsRef.current.forEach(unsetInitialSiblingItemStyles); // 2. repaint\n    siblingItemsRef.current = [];\n    placeholderItemRef.current = draggingItemRef.current = null;\n\n    const swappedItemIndexRange = { from: itemStartIndexRef.current, to: itemEndIndexRef.current };\n    itemStartIndexRef.current = itemEndIndexRef.current = ITEM_INITIAL_INDEX;\n    return swappedItemIndexRange;\n  };\n  const getShiftAndUnshiftItemsPreparedData = (\n    clientY: number,\n  ): [Array<[SiblingItem, Direction]>, Array<[SiblingItem, Direction]>] => {\n    const shiftItemEls: Array<[SiblingItem, Direction]> = [];\n    const unshiftItemEls: Array<[SiblingItem, Direction]> = [];\n    itemEndIndexRef.current = itemStartIndexRef.current;\n    siblingItemsRef.current.forEach((siblingItem) => {\n      const { isOverEl, isUnderEl } = getTargetIsOverOrUnderElData(\n        clientY,\n        getBoundingClientRect(siblingItem.el),\n      );\n      if (itemStartIndexRef.current < siblingItem.index) {\n        if (isOverEl) {\n          itemEndIndexRef.current = itemEndIndexRef.current + 1;\n          if (lastDragDirectionRef.current === 'down' && siblingItem.shifted) {\n            siblingItem.shifted = false;\n            shiftItemEls.push([siblingItem, 'up']);\n          }\n        }\n        if (isUnderEl) {\n          if (lastDragDirectionRef.current === 'up' && !siblingItem.shifted) {\n            siblingItem.shifted = true;\n            unshiftItemEls.push([siblingItem, 'down']);\n          }\n        }\n      } else if (itemStartIndexRef.current > siblingItem.index) {\n        if (isUnderEl) {\n          itemEndIndexRef.current = itemEndIndexRef.current - 1;\n          if (lastDragDirectionRef.current === 'up' && !siblingItem.shifted) {\n            siblingItem.shifted = true;\n            shiftItemEls.push([siblingItem, 'down']);\n          }\n        }\n        if (isOverEl) {\n          if (lastDragDirectionRef.current === 'down' && siblingItem.shifted) {\n            siblingItem.shifted = false;\n            unshiftItemEls.push([siblingItem, 'up']);\n          }\n        }\n      }\n    });\n    return [shiftItemEls, unshiftItemEls];\n  };\n  const setShiftAndUnshiftItemStyles = (\n    shiftItemEls: Array<[SiblingItem, Direction]>,\n    unshiftItemEls: Array<[SiblingItem, Direction]>,\n  ) => {\n    shiftItemEls.forEach((item) => setSiblingItemsShiftStyles(item, itemsGapRef.current));\n    unshiftItemEls.forEach((item) => setSiblingItemsShiftStyles(item, itemsGapRef.current));\n  };\n\n  const schedulingAutoScrollTimeoutIdRef = React.useRef<ReturnType<typeof setTimeout> | null>(null);\n  const clearSchedulingAutoScrollTimeout = () => {\n    if (schedulingAutoScrollTimeoutIdRef.current) {\n      clearTimeout(schedulingAutoScrollTimeoutIdRef.current);\n      schedulingAutoScrollTimeoutIdRef.current = null;\n    }\n  };\n  const tryAutoScroll = () => {\n    if (scrollControllerRef.current) {\n      scrollControllerRef.current.tryAutoScroll(() => {\n        return scrollElRef.current\n          ? getAutoScrollingData(lastClientYRef.current, scrollElRef.current)\n          : {\n              shouldScrolling: false,\n              y: 0,\n            };\n      });\n    }\n  };\n  const schedulingAutoScroll = () => {\n    clearSchedulingAutoScrollTimeout();\n    schedulingAutoScrollTimeoutIdRef.current = setTimeout(() => {\n      schedulingAutoScrollTimeoutIdRef.current = null;\n      tryAutoScroll();\n    }, AUTO_SCROLL_START_DELAY);\n  };\n\n  const onDragStart = (event: CustomTouchEvent) => {\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n  };\n\n  const onDragMove = (event: CustomTouchEvent) => {\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n\n    const draggingEl = draggingElRef.current;\n\n    if (!draggingEl) {\n      return;\n    }\n\n    if (dragging) {\n      lastDragDirectionRef.current = toggleDragDirection(lastDragShiftYRef.current, event.shiftY);\n      lastDragShiftYRef.current = event.shiftY;\n      lastClientYRef.current = event.clientY;\n\n      if (scrollControllerRef.current && scrollControllerRef.current.isRunning) {\n        setDraggingItemShiftStyles(draggingEl, lastDragShiftYRef.current);\n      } else {\n        const [shiftItemEls, unshiftItemEls] = getShiftAndUnshiftItemsPreparedData(\n          lastClientYRef.current,\n        );\n        setDraggingItemShiftStyles(draggingEl, lastDragShiftYRef.current);\n        setShiftAndUnshiftItemStyles(shiftItemEls, unshiftItemEls);\n        schedulingAutoScroll();\n      }\n    } else {\n      setDragging((prevDragging) => {\n        // На случай, если onDragMove успеет вызваться ещё раз до того, как `dragging` выставится в\n        // `true`\n        if (prevDragging) {\n          return prevDragging;\n        }\n        initializeScrollRefs(draggingEl);\n        initializeItems(draggingEl);\n        return true;\n      });\n    }\n  };\n\n  const onDragEnd = (event: CustomTouchEvent) => {\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n\n    clearSchedulingAutoScrollTimeout();\n    cleanupScrollRefs();\n\n    lastClientYRef.current = lastDragShiftYRef.current = 0;\n    lastDragDirectionRef.current = undefined;\n\n    if (dragging) {\n      const swappedItemRange = cleanupItems();\n      if (onDragFinish) {\n        onDragFinish(swappedItemRange);\n      }\n      setDragging(false);\n    }\n  };\n\n  const handleScroll = React.useCallback(() => {\n    if (!draggingElRef.current || !scrollElRef.current) {\n      return;\n    }\n\n    const nextScrollTop = getNodeScroll(scrollElRef.current).scrollTop;\n    lastDragDirectionRef.current = toggleDragDirection(lastScrollTopRef.current, nextScrollTop);\n    const scrollDiff = lastScrollTopRef.current - nextScrollTop;\n    const clientYWithScrollOffset = lastClientYRef.current + scrollDiff;\n    lastScrollTopRef.current = nextScrollTop;\n\n    const [shiftItemEls, unshiftItemEls] =\n      getShiftAndUnshiftItemsPreparedData(clientYWithScrollOffset);\n    setShiftAndUnshiftItemStyles(shiftItemEls, unshiftItemEls);\n  }, [draggingElRef]);\n\n  useIsomorphicLayoutEffect(\n    function recalculateOnScroll() {\n      const scrollEl = scrollElRef.current;\n      if (!dragging || !scrollEl) {\n        return;\n      }\n      scrollEl.addEventListener('scroll', handleScroll);\n      return () => {\n        if (scrollEl) {\n          scrollEl.removeEventListener('scroll', handleScroll);\n        }\n      };\n    },\n    [dragging, handleScroll],\n  );\n\n  useIsomorphicLayoutEffect(\n    () =>\n      function componentWillUnmount() {\n        if (placeholderItemRef.current) {\n          unsetInitialPlaceholderItemStyles(placeholderItemRef.current);\n        }\n      },\n    [],\n  );\n\n  return { dragging, onDragStart, onDragMove, onDragEnd };\n};\n"],"names":["useDraggableWithDomApi","elRef","draggingElRef","onDragFinish","dragging","setDragging","React","useState","lastClientYRef","useRef","lastDragShiftYRef","scrollElRef","lastScrollTopRef","scrollControllerRef","initializeScrollRefs","draggableEl","node","getNearestOverflowAncestor","current","getNodeScroll","scrollTop","createAutoScrollController","cleanupScrollRefs","stop","lastDragDirectionRef","undefined","toggleDragDirection","prevShiftY","nextShiftY","shiftYDiff","itemStartIndexRef","ITEM_INITIAL_INDEX","itemEndIndexRef","draggingItemRef","placeholderItemRef","siblingItemsRef","itemsGapRef","initializeItems","draggingEl","draggingElRect","getBoundingClientRect","parentElement","parseInt","style","gridGap","children","Array","prototype","forEach","call","el","index","getAttribute","DATA_DRAGGABLE_PLACEHOLDER_KEY","push","shifted","setInitialPlaceholderItemStyles","setInitialDraggingItemStyles","sibling","setInitialSiblingItemStyles","cleanupItems","unsetInitialPlaceholderItemStyles","unsetInitialDraggingItemStyles","unsetInitialSiblingItemStyles","swappedItemIndexRange","from","to","getShiftAndUnshiftItemsPreparedData","clientY","shiftItemEls","unshiftItemEls","siblingItem","isOverEl","isUnderEl","getTargetIsOverOrUnderElData","setShiftAndUnshiftItemStyles","item","setSiblingItemsShiftStyles","schedulingAutoScrollTimeoutIdRef","clearSchedulingAutoScrollTimeout","clearTimeout","tryAutoScroll","getAutoScrollingData","shouldScrolling","y","schedulingAutoScroll","setTimeout","AUTO_SCROLL_START_DELAY","onDragStart","event","originalEvent","stopPropagation","preventDefault","onDragMove","shiftY","isRunning","setDraggingItemShiftStyles","prevDragging","onDragEnd","swappedItemRange","handleScroll","useCallback","nextScrollTop","scrollDiff","clientYWithScrollOffset","useIsomorphicLayoutEffect","recalculateOnScroll","scrollEl","addEventListener","removeEventListener","componentWillUnmount"],"mappings":"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"}